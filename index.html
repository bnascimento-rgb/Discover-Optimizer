    function classifyEntity(seed, hint){
      const ents = extractKeywords(seed);
      let ent = hint || ents.find(e=>!/^(novo|veja|entenda|descubra|saiba)$/i.test(e)) || ents[0] || seed;
      return ent.replace(/^\d+\s+/, '');
    }

    // ===== VALIDAÇÃO DE COERÊNCIA =====
    function isCoherent(title, seed) {
      const tl = title.toLowerCase();
      const sl = seed.toLowerCase();
      
      // Descarta se repete a mesma palavra 3+ vezes
      const words = tl.split(/\s+/);
      const freq = {};
      for (const w of words) {
        if (w.length < 3) continue;
        freq[w] = (freq[w] || 0) + 1;
        if (freq[w] >= 3) return false;
      }
      
      // Descarta se tem padrões incoerentes
      if (/^veja:.*como|^veja:.*passo a passo/.test(tl)) return false;
      if (/^aprenda:.*vale a pena/.test(tl)) return false;
      if (/^descubra:.*o que muda/.test(tl)) return false;
      
      // Descarta se título muito genérico (só stopwords + entidade)
      const nonStop = words.filter(w => !STOP.has(w) && w.length > 2);
      if (nonStop.length < 3) return false;
      
      // Mantém apenas se houver overlap significativo com seed
      const seedTokens = tokenSet(sl);
      const titleTokens = tokenSet(tl);
      let overlap = 0;
      for (const t of titleTokens) {
        if (seedTokens.has(t)) overlap++;
      }
      
      return overlap >= 2;
    }

    // ===== SCORE MELHORADO =====
    function betterScore(title, seed, topicKeywords, minLen, maxLen) {
      let s = score(title, topicKeywords, minLen, maxLen);
      
      const tl = title.toLowerCase();
      const sl = seed.toLowerCase();
      
      // Penaliza redundância de palavras
      const words = tl.split(/\s+/).filter(w => w.length > 3);
      const unique = new Set(words);
      if (words.length > unique.size) s -= 1;
      
      // Penaliza se não captura essência do seed
      const seedWords = tokenSet(seed);
      const titleWords = tokenSet(title);
      let captured = 0;
      for (const w of seedWords) {
        if (titleWords.has(w)) captured++;
      }
      if (captured < 2) s -= 3;
      if (captured >= 4) s += 1;
      
      // Bonifica se mantém números do original
      const seedNum = seed.match(/\d+/g);
      const titleNum = title.match(/\d+/g);
      if (seedNum && titleNum && seedNum[0] === titleNum[0]) s += 2;
      
      // Bonifica estruturas claras
      if (/^[^:]+:\s+(o que|como|quando|quem|quanto|vale|guia)/.test(tl)) s += 1;
      
      // Penaliza se entidade não está no início
      const firstWord = tl.split(/\s+/)[0];
      const entTokens = tokenSet(topicKeywords.join(' '));
      if (!entTokens.has(firstWord)) s -= 1;
      
      return s;
    }

    // ===== SELEÇÃO DE MOLDES POR CONTEXTO =====
    function selectMolds(seed, intents) {
      const isListSeed = /(^\d+\b|\btop\b|\bmelhores\b)/i.test(seed);
      
      if (isListSeed) {
        return [
          "{ent}: nossa seleção comentada",
          "{ent}: como escolher o melhor (guia rápido)",
          "{ent}: {n} critérios essenciais antes de decidir",
          "{ent}: comparação de prós e contras",
          "Como escolher {ent}: {guia}",
          "{ent}: {pergunta}",
        ];
      }
      
      if (intents.includes("policy") && intents.includes("news")) {
        return [
          "{ent}: o que muda {contexto}",
          "{ent}: quando entra em vigor e quem é afetado",
          "{ent} explicado: {beneficio_curto}",
          "{ent}: {comparacao} vale a pena?",
          "Como {beneficio} com {ent}",
          "{ent}: {pergunta}",
        ];
      }
      
      if (intents.includes("shopping") || intents.includes("compare")) {
        return [
          "{ent}: {pergunta}",
          "Como {beneficio} com {ent}",
          "{ent}: {guia}",
          "{ent}: {comparacao} vale a pena?",
          "{ent}: {beneficio_curto}",
        ];
      }
      
      if (intents.includes("guide") || intents.includes("howto")) {
        return [
          "Como {beneficio} com {ent}",
          "{ent}: {guia}",
          "{ent}: {n} pontos para {beneficio}",
          "{ent} explicado: {beneficio_curto}",
          "{ent}: {pergunta}",
        ];
      }
      
      // Templates gerais
      return [
        "{ent}: o que muda {contexto}",
        "Como {beneficio} com {ent}",
        "{ent} explicado: {beneficio_curto}",
        "{ent}: {pergunta}",
        "{ent}: {guia}",
        "{ent}: {comparacao} vale a pena?",
      ];
    }

    function generate(seed, entityHint=null, minLen=40, maxLen=68){
      seed = clean(seed);
      const ent = classifyEntity(seed, entityHint);
      const intents = detectIntents(seed);
      const slots = buildSlots(seed, ent);

      const molds = selectMolds(seed, intents);
      const out = new Set();

      // Gera combinações limitadas e validadas
      for (const mold of molds){
        const keys = [...mold.matchAll(/\{(\w+)\}/g)].map(m=>m[1]);
        // LIMITA a 2 variantes por slot para reduzir combinações
        const lists = keys.map(k=>(slots[k]||[""]).slice(0, 2));
        
        function loop(idx, acc){
          if (idx===lists.length){
            let t = mold; 
            keys.forEach((k,i)=>{ t = t.replace(`{${k}}`, acc[i]) });
            t = clean(t); 
            t = t.charAt(0).toUpperCase() + t.slice(1);
            
            // VALIDA coerência antes de adicionar
            if (t.length >= 30 && t.length <= 90 && isCoherent(t, seed)) {
              out.add(t);
            }
            return;
          }
          for (const item of lists[idx]) loop(idx+1, [...acc, item]);
        }
        loop(0, []);
      }
      
      // Adiciona o original e uma variação segura
      out.add(seed);
      const seedBase = clean(seed.replace(/:.*/, ""));
      if (seedBase.length < 80) {
        out.add(seedBase + ": o que muda e quando");
      }

      const kw = extractKeywords(seed);
      const scored = [...out].map(t=>({
        title: t,
        score: betterScore(t, seed, kw, minLen, maxLen),
        angle: classifyAngle(t),
        len: t.length
      }))
      .filter(x=>x.len>=30 && x.len<=90)
      .sort((a,b)=> b.score - a.score);

      return scored;
    }